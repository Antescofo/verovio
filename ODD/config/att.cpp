std::string Att::AccidentalExplicitToStr(data_ACCIDENTAL_EXPLICIT data){    std::string value;    switch(data)    {        case data_ACCIDENTAL_EXPLICIT_s : value = "s"; break; // sharp        case data_ACCIDENTAL_EXPLICIT_f : value = "f"; break; // flat        case data_ACCIDENTAL_EXPLICIT_x : value = "x"; break; // double sharp (written using croix)        case data_ACCIDENTAL_EXPLICIT_ff : value = "ff"; break; // double flat        case data_ACCIDENTAL_EXPLICIT_n : value = "n"; break; // natural        case data_ACCIDENTAL_EXPLICIT_nf : value = "nf"; break; // natural + flat; used to cancel preceding double flat        case data_ACCIDENTAL_EXPLICIT_ns : value = "ns"; break; // natural + sharp; used to cancel preceding double sharp        default:            LogWarning("Unknown AccidentalExplicit '%d'", data);            value = "";            break;    }    return value;}data_ACCIDENTAL_EXPLICIT Att::StrToAccidentalExplicit(std::string value){    if (value == "s") return data_ACCIDENTAL_EXPLICIT_s; // sharp    else if (value == "f") return data_ACCIDENTAL_EXPLICIT_f; // flat    else if (value == "x") return data_ACCIDENTAL_EXPLICIT_x; // double sharp (written using croix)    else if (value == "ff") return data_ACCIDENTAL_EXPLICIT_ff; // double flat    else if (value == "n") return data_ACCIDENTAL_EXPLICIT_n; // natural    else if (value == "nf") return data_ACCIDENTAL_EXPLICIT_nf; // natural + flat; used to cancel preceding double flat    else if (value == "ns") return data_ACCIDENTAL_EXPLICIT_ns; // natural + sharp; used to cancel preceding double sharp    else {        LogWarning("Unknown AccidentalExplicit '%s'", value.c_str() );    }    return ACCIDENTAL_EXPLICIT_NONE;}std::string Att::AccidentalImplicitToStr(data_ACCIDENTAL_IMPLICIT data){    std::string value;    switch(data)    {        case data_ACCIDENTAL_IMPLICIT_s : value = "s"; break; // sharp        case data_ACCIDENTAL_IMPLICIT_f : value = "f"; break; // flat        case data_ACCIDENTAL_IMPLICIT_ss : value = "ss"; break; // double sharp        case data_ACCIDENTAL_IMPLICIT_ff : value = "ff"; break; // double flat        case data_ACCIDENTAL_IMPLICIT_n : value = "n"; break; // natural        case data_ACCIDENTAL_IMPLICIT_su : value = "su"; break; // three quarter-tones sharp        case data_ACCIDENTAL_IMPLICIT_sd : value = "sd"; break; // quarter-tone sharp        case data_ACCIDENTAL_IMPLICIT_fu : value = "fu"; break; // quarter-tone flat        case data_ACCIDENTAL_IMPLICIT_fd : value = "fd"; break; // three quarter-tones flat        default:            LogWarning("Unknown AccidentalImplicit '%d'", data);            value = "";            break;    }    return value;}data_ACCIDENTAL_IMPLICIT Att::StrToAccidentalImplicit(std::string value){    if (value == "s") return data_ACCIDENTAL_IMPLICIT_s; // sharp    else if (value == "f") return data_ACCIDENTAL_IMPLICIT_f; // flat    else if (value == "ss") return data_ACCIDENTAL_IMPLICIT_ss; // double sharp    else if (value == "ff") return data_ACCIDENTAL_IMPLICIT_ff; // double flat    else if (value == "n") return data_ACCIDENTAL_IMPLICIT_n; // natural    else if (value == "su") return data_ACCIDENTAL_IMPLICIT_su; // three quarter-tones sharp    else if (value == "sd") return data_ACCIDENTAL_IMPLICIT_sd; // quarter-tone sharp    else if (value == "fu") return data_ACCIDENTAL_IMPLICIT_fu; // quarter-tone flat    else if (value == "fd") return data_ACCIDENTAL_IMPLICIT_fd; // three quarter-tones flat    else {        LogWarning("Unknown AccidentalImplicit '%s'", value.c_str() );    }    return ACCIDENTAL_IMPLICIT_NONE;}std::string Att::ArticulationToStr(data_ARTICULATION data){    std::string value;    switch(data)    {        case data_ARTICULATION_acc : value = "acc"; break; // accent (Unicode 1D17B)        case data_ARTICULATION_stacc : value = "stacc"; break; // staccato (Unicode 1D17C)        case data_ARTICULATION_ten : value = "ten"; break; // tenuto (Unicode 1D17D)        case data_ARTICULATION_stacciss : value = "stacciss"; break; // staccatissimo (Unicode 1D17E)        case data_ARTICULATION_marc : value = "marc"; break; // marcato (Unicode 1D17F)        case data_ARTICULATION_marc-stacc : value = "marc-stacc"; break; // marcato + staccato (Unicode 1D180)        case data_ARTICULATION_spicc : value = "spicc"; break; // spiccato        case data_ARTICULATION_doit : value = "doit"; break; // main note followed by short slide to higher, indeterminate pitch (Unicode 1D185)        case data_ARTICULATION_rip : value = "rip"; break; // main note preceded by short slide from lower, indeterminate pitch (Unicode 1D186)        case data_ARTICULATION_plop : value = "plop"; break; // main note preceded by "slide" from higher, indeterminate pitch        case data_ARTICULATION_fall : value = "fall"; break; // main note followed by long "slide" to lower, indeterminate pitch        case data_ARTICULATION_bend : value = "bend"; break; // "lip slur" to lower pitch, then return to written pitch        case data_ARTICULATION_flip : value = "flip"; break; // main note followed by quick upward rise, then descent in pitch (Unicode 1D187)        case data_ARTICULATION_smear : value = "smear"; break; // (Unicode 1D188)        case data_ARTICULATION_dnbow : value = "dnbow"; break; // down bow (Unicode 1D1AA)        case data_ARTICULATION_upbow : value = "upbow"; break; // up bow (Unicode 1D1AB)        case data_ARTICULATION_harm : value = "harm"; break; // harmonic (Unicode 1D1AC)        case data_ARTICULATION_snap : value = "snap"; break; // snap pizzicato (Unicode 1D1AD)        case data_ARTICULATION_fingernail : value = "fingernail"; break; // fingernail (Unicode 1D1B3)        case data_ARTICULATION_ten-stacc : value = "ten-stacc"; break; // tenuto + staccato (Unicode 1D182)        case data_ARTICULATION_damp : value = "damp"; break; // dampen harp string (Unicode 1D1B4)        case data_ARTICULATION_dampall : value = "dampall"; break; // dampen all harp strings (Unicode 1D1B5)        case data_ARTICULATION_open : value = "open"; break; // full (as opposed to stopped) tone        case data_ARTICULATION_stop : value = "stop"; break; // "muffled" tone        case data_ARTICULATION_dbltongue : value = "dbltongue"; break; // double tongue (Unicode 1D18A)        case data_ARTICULATION_trpltongue : value = "trpltongue"; break; // triple tongue (Unicode 1D18B)        case data_ARTICULATION_heel : value = "heel"; break; // use heel (organ pedal)        case data_ARTICULATION_toe : value = "toe"; break; // use toe (organ pedal)        case data_ARTICULATION_tap : value = "tap"; break; // percussive effect on guitar string(s)        case data_ARTICULATION_lhpizz : value = "lhpizz"; break; // left-hand pizzicato        case data_ARTICULATION_dot : value = "dot"; break; // uninterpreted dot        case data_ARTICULATION_stroke : value = "stroke"; break; // uninterpreted stroke        default:            LogWarning("Unknown Articulation '%d'", data);            value = "";            break;    }    return value;}data_ARTICULATION Att::StrToArticulation(std::string value){    if (value == "acc") return data_ARTICULATION_acc; // accent (Unicode 1D17B)    else if (value == "stacc") return data_ARTICULATION_stacc; // staccato (Unicode 1D17C)    else if (value == "ten") return data_ARTICULATION_ten; // tenuto (Unicode 1D17D)    else if (value == "stacciss") return data_ARTICULATION_stacciss; // staccatissimo (Unicode 1D17E)    else if (value == "marc") return data_ARTICULATION_marc; // marcato (Unicode 1D17F)    else if (value == "marc-stacc") return data_ARTICULATION_marc-stacc; // marcato + staccato (Unicode 1D180)    else if (value == "spicc") return data_ARTICULATION_spicc; // spiccato    else if (value == "doit") return data_ARTICULATION_doit; // main note followed by short slide to higher, indeterminate pitch (Unicode 1D185)    else if (value == "rip") return data_ARTICULATION_rip; // main note preceded by short slide from lower, indeterminate pitch (Unicode 1D186)    else if (value == "plop") return data_ARTICULATION_plop; // main note preceded by "slide" from higher, indeterminate pitch    else if (value == "fall") return data_ARTICULATION_fall; // main note followed by long "slide" to lower, indeterminate pitch    else if (value == "bend") return data_ARTICULATION_bend; // "lip slur" to lower pitch, then return to written pitch    else if (value == "flip") return data_ARTICULATION_flip; // main note followed by quick upward rise, then descent in pitch (Unicode 1D187)    else if (value == "smear") return data_ARTICULATION_smear; // (Unicode 1D188)    else if (value == "dnbow") return data_ARTICULATION_dnbow; // down bow (Unicode 1D1AA)    else if (value == "upbow") return data_ARTICULATION_upbow; // up bow (Unicode 1D1AB)    else if (value == "harm") return data_ARTICULATION_harm; // harmonic (Unicode 1D1AC)    else if (value == "snap") return data_ARTICULATION_snap; // snap pizzicato (Unicode 1D1AD)    else if (value == "fingernail") return data_ARTICULATION_fingernail; // fingernail (Unicode 1D1B3)    else if (value == "ten-stacc") return data_ARTICULATION_ten-stacc; // tenuto + staccato (Unicode 1D182)    else if (value == "damp") return data_ARTICULATION_damp; // dampen harp string (Unicode 1D1B4)    else if (value == "dampall") return data_ARTICULATION_dampall; // dampen all harp strings (Unicode 1D1B5)    else if (value == "open") return data_ARTICULATION_open; // full (as opposed to stopped) tone    else if (value == "stop") return data_ARTICULATION_stop; // "muffled" tone    else if (value == "dbltongue") return data_ARTICULATION_dbltongue; // double tongue (Unicode 1D18A)    else if (value == "trpltongue") return data_ARTICULATION_trpltongue; // triple tongue (Unicode 1D18B)    else if (value == "heel") return data_ARTICULATION_heel; // use heel (organ pedal)    else if (value == "toe") return data_ARTICULATION_toe; // use toe (organ pedal)    else if (value == "tap") return data_ARTICULATION_tap; // percussive effect on guitar string(s)    else if (value == "lhpizz") return data_ARTICULATION_lhpizz; // left-hand pizzicato    else if (value == "dot") return data_ARTICULATION_dot; // uninterpreted dot    else if (value == "stroke") return data_ARTICULATION_stroke; // uninterpreted stroke    else {        LogWarning("Unknown Articulation '%s'", value.c_str() );    }    return ARTICULATION_NONE;}std::string Att::BarplaceToStr(data_BARPLACE data){    std::string value;    switch(data)    {        case data_BARPLACE_mensur : value = "mensur"; break; // between staves only        case data_BARPLACE_staff : value = "staff"; break; // between and across staves as necessary        case data_BARPLACE_takt : value = "takt"; break; // short line above staff or through top line        default:            LogWarning("Unknown Barplace '%d'", data);            value = "";            break;    }    return value;}data_BARPLACE Att::StrToBarplace(std::string value){    if (value == "mensur") return data_BARPLACE_mensur; // between staves only    else if (value == "staff") return data_BARPLACE_staff; // between and across staves as necessary    else if (value == "takt") return data_BARPLACE_takt; // short line above staff or through top line    else {        LogWarning("Unknown Barplace '%s'", value.c_str() );    }    return BARPLACE_NONE;}std::string Att::BarrenditionToStr(data_BARRENDITION data){    std::string value;    switch(data)    {        case data_BARRENDITION_dbl : value = "dbl"; break; // (Unicode 1D101)        case data_BARRENDITION_end : value = "end"; break; // (Unicode 1D102)        case data_BARRENDITION_rptstart : value = "rptstart"; break; // repeat start (Unicode 1D106)        case data_BARRENDITION_rptboth : value = "rptboth"; break; // repeat start and end        case data_BARRENDITION_rptend : value = "rptend"; break; // repeat end (Unicode 1D107)        case data_BARRENDITION_single : value = "single"; break; // (Unicode 1D100)        default:            LogWarning("Unknown Barrendition '%d'", data);            value = "";            break;    }    return value;}data_BARRENDITION Att::StrToBarrendition(std::string value){    if (value == "dbl") return data_BARRENDITION_dbl; // (Unicode 1D101)    else if (value == "end") return data_BARRENDITION_end; // (Unicode 1D102)    else if (value == "rptstart") return data_BARRENDITION_rptstart; // repeat start (Unicode 1D106)    else if (value == "rptboth") return data_BARRENDITION_rptboth; // repeat start and end    else if (value == "rptend") return data_BARRENDITION_rptend; // repeat end (Unicode 1D107)    else if (value == "single") return data_BARRENDITION_single; // (Unicode 1D100)    else {        LogWarning("Unknown Barrendition '%s'", value.c_str() );    }    return BARRENDITION_NONE;}std::string Att::BeatrptRendToStr(data_BEATRPT_REND data){    std::string value;    switch(data)    {        default:            LogWarning("Unknown BeatrptRend '%d'", data);            value = "";            break;    }    return value;}data_BEATRPT_REND Att::StrToBeatrptRend(std::string value){    if (value == "") return data_BEATRPT_REND_; //     else {        LogWarning("Unknown BeatrptRend '%s'", value.c_str() );    }    return BEATRPT_REND_NONE;}std::string Att::BendAmountToStr(data_BEND_AMOUNT data){    std::string value;    switch(data)    {        default:            LogWarning("Unknown BendAmount '%d'", data);            value = "";            break;    }    return value;}data_BEND_AMOUNT Att::StrToBendAmount(std::string value){    if (value == "") return data_BEND_AMOUNT_; //     else {        LogWarning("Unknown BendAmount '%s'", value.c_str() );    }    return BEND_AMOUNT_NONE;}std::string Att::BooleanToStr(data_BOOLEAN data){    std::string value;    switch(data)    {        case data_BOOLEAN_true : value = "true"; break; //         case data_BOOLEAN_false : value = "false"; break; //         default:            LogWarning("Unknown Boolean '%d'", data);            value = "";            break;    }    return value;}data_BOOLEAN Att::StrToBoolean(std::string value){    if (value == "true") return data_BOOLEAN_true; //     else if (value == "false") return data_BOOLEAN_false; //     else {        LogWarning("Unknown Boolean '%s'", value.c_str() );    }    return BOOLEAN_NONE;}std::string Att::ClefshapeToStr(data_CLEFSHAPE data){    std::string value;    switch(data)    {        case data_CLEFSHAPE_G : value = "G"; break; // G clef (Unicode 1D11E)        case data_CLEFSHAPE_GG : value = "GG"; break; // Double G clef        case data_CLEFSHAPE_F : value = "F"; break; // F clef (Unicode 1D122)        case data_CLEFSHAPE_C : value = "C"; break; // C clef (Unicode 1D121)        case data_CLEFSHAPE_perc : value = "perc"; break; // Drum clef (Unicode 1D125 or Unicode 1D126)        case data_CLEFSHAPE_TAB : value = "TAB"; break; // tablature "clef"; i.e. usually "TAB" rendered vertically        default:            LogWarning("Unknown Clefshape '%d'", data);            value = "";            break;    }    return value;}data_CLEFSHAPE Att::StrToClefshape(std::string value){    if (value == "G") return data_CLEFSHAPE_G; // G clef (Unicode 1D11E)    else if (value == "GG") return data_CLEFSHAPE_GG; // Double G clef    else if (value == "F") return data_CLEFSHAPE_F; // F clef (Unicode 1D122)    else if (value == "C") return data_CLEFSHAPE_C; // C clef (Unicode 1D121)    else if (value == "perc") return data_CLEFSHAPE_perc; // Drum clef (Unicode 1D125 or Unicode 1D126)    else if (value == "TAB") return data_CLEFSHAPE_TAB; // tablature "clef"; i.e. usually "TAB" rendered vertically    else {        LogWarning("Unknown Clefshape '%s'", value.c_str() );    }    return CLEFSHAPE_NONE;}std::string Att::ClusterToStr(data_CLUSTER data){    std::string value;    switch(data)    {        case data_CLUSTER_whbox : value = "whbox"; break; // unfilled box        case data_CLUSTER_blbox : value = "blbox"; break; // filled box        default:            LogWarning("Unknown Cluster '%d'", data);            value = "";            break;    }    return value;}data_CLUSTER Att::StrToCluster(std::string value){    if (value == "whbox") return data_CLUSTER_whbox; // unfilled box    else if (value == "blbox") return data_CLUSTER_blbox; // filled box    else {        LogWarning("Unknown Cluster '%s'", value.c_str() );    }    return CLUSTER_NONE;}std::string Att::ColorToStr(data_COLOR data){    std::string value;    switch(data)    {        case data_COLOR_aqua : value = "aqua"; break; //         case data_COLOR_black : value = "black"; break; //         case data_COLOR_blue : value = "blue"; break; //         case data_COLOR_fuchsia : value = "fuchsia"; break; //         case data_COLOR_gray : value = "gray"; break; //         case data_COLOR_green : value = "green"; break; //         case data_COLOR_lime : value = "lime"; break; //         case data_COLOR_maroon : value = "maroon"; break; //         case data_COLOR_navy : value = "navy"; break; //         case data_COLOR_olive : value = "olive"; break; //         case data_COLOR_purple : value = "purple"; break; //         case data_COLOR_red : value = "red"; break; //         case data_COLOR_silver : value = "silver"; break; //         case data_COLOR_teal : value = "teal"; break; //         case data_COLOR_white : value = "white"; break; //         case data_COLOR_yellow : value = "yellow"; break; //         default:            LogWarning("Unknown Color '%d'", data);            value = "";            break;    }    return value;}data_COLOR Att::StrToColor(std::string value){    if (value == "aqua") return data_COLOR_aqua; //     else if (value == "black") return data_COLOR_black; //     else if (value == "blue") return data_COLOR_blue; //     else if (value == "fuchsia") return data_COLOR_fuchsia; //     else if (value == "gray") return data_COLOR_gray; //     else if (value == "green") return data_COLOR_green; //     else if (value == "lime") return data_COLOR_lime; //     else if (value == "maroon") return data_COLOR_maroon; //     else if (value == "navy") return data_COLOR_navy; //     else if (value == "olive") return data_COLOR_olive; //     else if (value == "purple") return data_COLOR_purple; //     else if (value == "red") return data_COLOR_red; //     else if (value == "silver") return data_COLOR_silver; //     else if (value == "teal") return data_COLOR_teal; //     else if (value == "white") return data_COLOR_white; //     else if (value == "yellow") return data_COLOR_yellow; //     else {        LogWarning("Unknown Color '%s'", value.c_str() );    }    return COLOR_NONE;}std::string Att::CurverenditionToStr(data_CURVERENDITION data){    std::string value;    switch(data)    {        case data_CURVERENDITION_narrow : value = "narrow"; break; // default line width        case data_CURVERENDITION_medium : value = "medium"; break; // twice as wide as normal        case data_CURVERENDITION_wide : value = "wide"; break; // twice as wide as medium        case data_CURVERENDITION_dashed : value = "dashed"; break; // dashed        case data_CURVERENDITION_dotted : value = "dotted"; break; // dotted        default:            LogWarning("Unknown Curverendition '%d'", data);            value = "";            break;    }    return value;}data_CURVERENDITION Att::StrToCurverendition(std::string value){    if (value == "narrow") return data_CURVERENDITION_narrow; // default line width    else if (value == "medium") return data_CURVERENDITION_medium; // twice as wide as normal    else if (value == "wide") return data_CURVERENDITION_wide; // twice as wide as medium    else if (value == "dashed") return data_CURVERENDITION_dashed; // dashed    else if (value == "dotted") return data_CURVERENDITION_dotted; // dotted    else {        LogWarning("Unknown Curverendition '%s'", value.c_str() );    }    return CURVERENDITION_NONE;}std::string Att::DurationGesturalToStr(data_DURATION_gestural data){    std::string value;    switch(data)    {        default:            LogWarning("Unknown DurationGestural '%d'", data);            value = "";            break;    }    return value;}data_DURATION_gestural Att::StrToDurationGestural(std::string value){    if (value == "") return data_DURATION_gestural_; //     else {        LogWarning("Unknown DurationGestural '%s'", value.c_str() );    }    return DURATION_gestural_NONE;}std::string Att::EnclosureToStr(data_ENCLOSURE data){    std::string value;    switch(data)    {        case data_ENCLOSURE_paren : value = "paren"; break; // parentheses        case data_ENCLOSURE_brack : value = "brack"; break; // square brackets        default:            LogWarning("Unknown Enclosure '%d'", data);            value = "";            break;    }    return value;}data_ENCLOSURE Att::StrToEnclosure(std::string value){    if (value == "paren") return data_ENCLOSURE_paren; // parentheses    else if (value == "brack") return data_ENCLOSURE_brack; // square brackets    else {        LogWarning("Unknown Enclosure '%s'", value.c_str() );    }    return ENCLOSURE_NONE;}std::string Att::FontstyleToStr(data_FONTSTYLE data){    std::string value;    switch(data)    {        case data_FONTSTYLE_italic : value = "italic"; break; // text slants to right        case data_FONTSTYLE_normal : value = "normal"; break; // unadorned        case data_FONTSTYLE_oblique : value = "oblique"; break; // text slants to the left        default:            LogWarning("Unknown Fontstyle '%d'", data);            value = "";            break;    }    return value;}data_FONTSTYLE Att::StrToFontstyle(std::string value){    if (value == "italic") return data_FONTSTYLE_italic; // text slants to right    else if (value == "normal") return data_FONTSTYLE_normal; // unadorned    else if (value == "oblique") return data_FONTSTYLE_oblique; // text slants to the left    else {        LogWarning("Unknown Fontstyle '%s'", value.c_str() );    }    return FONTSTYLE_NONE;}std::string Att::FontweightToStr(data_FONTWEIGHT data){    std::string value;    switch(data)    {        case data_FONTWEIGHT_bold : value = "bold"; break; //         case data_FONTWEIGHT_normal : value = "normal"; break; //         default:            LogWarning("Unknown Fontweight '%d'", data);            value = "";            break;    }    return value;}data_FONTWEIGHT Att::StrToFontweight(std::string value){    if (value == "bold") return data_FONTWEIGHT_bold; //     else if (value == "normal") return data_FONTWEIGHT_normal; //     else {        LogWarning("Unknown Fontweight '%s'", value.c_str() );    }    return FONTWEIGHT_NONE;}std::string Att::GlissandoToStr(data_GLISSANDO data){    std::string value;    switch(data)    {        case data_GLISSANDO_i : value = "i"; break; // first note/chord in glissando        case data_GLISSANDO_m : value = "m"; break; // note/chord that's neither first nor last in glissando        case data_GLISSANDO_t : value = "t"; break; // last note in glissando        default:            LogWarning("Unknown Glissando '%d'", data);            value = "";            break;    }    return value;}data_GLISSANDO Att::StrToGlissando(std::string value){    if (value == "i") return data_GLISSANDO_i; // first note/chord in glissando    else if (value == "m") return data_GLISSANDO_m; // note/chord that's neither first nor last in glissando    else if (value == "t") return data_GLISSANDO_t; // last note in glissando    else {        LogWarning("Unknown Glissando '%s'", value.c_str() );    }    return GLISSANDO_NONE;}std::string Att::GraceToStr(data_GRACE data){    std::string value;    switch(data)    {        case data_GRACE_acc : value = "acc"; break; // time "stolen" from following note        case data_GRACE_unacc : value = "unacc"; break; // time "stolen" from previous note        case data_GRACE_unknown : value = "unknown"; break; // no interpretation regarding performed value of grace note        default:            LogWarning("Unknown Grace '%d'", data);            value = "";            break;    }    return value;}data_GRACE Att::StrToGrace(std::string value){    if (value == "acc") return data_GRACE_acc; // time "stolen" from following note    else if (value == "unacc") return data_GRACE_unacc; // time "stolen" from previous note    else if (value == "unknown") return data_GRACE_unknown; // no interpretation regarding performed value of grace note    else {        LogWarning("Unknown Grace '%s'", value.c_str() );    }    return GRACE_NONE;}std::string Att::HeadshapeToStr(data_HEADSHAPE data){    std::string value;    switch(data)    {        case data_HEADSHAPE_quarter : value = "quarter"; break; // filled oval (Unicode 1D158)        case data_HEADSHAPE_half : value = "half"; break; // open oval (Unicode 1D157)        case data_HEADSHAPE_whole : value = "whole"; break; // open oval (Unicode 1D15D)        case data_HEADSHAPE_dblwhole : value = "dblwhole"; break; // modern breve (Unicode 1D15C)        case data_HEADSHAPE_filldiamond : value = "filldiamond"; break; // filled diamond (Unicode 1D1BA)        case data_HEADSHAPE_diamond : value = "diamond"; break; // open diamond (Unicode 1D1B9)        case data_HEADSHAPE_dwdiamond : value = "dwdiamond"; break; // double whole diamond (Mup)        case data_HEADSHAPE_fillisotriangle : value = "fillisotriangle"; break; // filled isosceles triangle (Unicode 1D149)        case data_HEADSHAPE_isotriangle : value = "isotriangle"; break; // open isosceles triangle (Unicode 1D148)        case data_HEADSHAPE_dwhisotriangle : value = "dwhisotriangle"; break; // double whole open isosceles triangle (Unicode 1D14E)        case data_HEADSHAPE_fillpiewedge : value = "fillpiewedge"; break; // filled downward-pointing wedge (Unicode 1D155)        case data_HEADSHAPE_piewedge : value = "piewedge"; break; // downward-pointing wedge (Unicode 1D154)        case data_HEADSHAPE_dwhpiewedge : value = "dwhpiewedge"; break; // double whole downward-pointing wedge (Mup)        case data_HEADSHAPE_fillrectangle : value = "fillrectangle"; break; // filled rectangle (Unicode 1D147)        case data_HEADSHAPE_rectangle : value = "rectangle"; break; // open rectangle (Unicode 1D146)        case data_HEADSHAPE_dwhrectangle : value = "dwhrectangle"; break; // double whole open rectangle (Mup)        case data_HEADSHAPE_fillrtriangle : value = "fillrtriangle"; break; // filled right triangle (Unicode 1D14B)        case data_HEADSHAPE_rtriangle : value = "rtriangle"; break; // open right triangle (Unicode 1D14A)        case data_HEADSHAPE_dwrtriangle : value = "dwrtriangle"; break; // double whole right triangle (Mup)        case data_HEADSHAPE_fillurtriangle : value = "fillurtriangle"; break; // filled upper right triangle (Unicode 1D151)        case data_HEADSHAPE_urtriangle : value = "urtriangle"; break; // open upper right triangle (Unicode 1D150)        case data_HEADSHAPE_dwurtriangle : value = "dwurtriangle"; break; // double whole upper right triangle        case data_HEADSHAPE_fillsemicircle : value = "fillsemicircle"; break; // filled semi-circle (Unicode 1D153)        case data_HEADSHAPE_semicircle : value = "semicircle"; break; // open semi-circle (Unicode 1D152)        case data_HEADSHAPE_dwsemicircle : value = "dwsemicircle"; break; // double whole open semi-circle (Mup)        case data_HEADSHAPE_fillslash : value = "fillslash"; break; // filled slash (Mup)        case data_HEADSHAPE_slash : value = "slash"; break; // open slash (Mup)        case data_HEADSHAPE_dwslash : value = "dwslash"; break; // double whole open slash (Mup)        case data_HEADSHAPE_x : value = "x"; break; // X (Unicode 1D143)        case data_HEADSHAPE_blank : value = "blank"; break; // note head not rendered (Unicode 1D159)        case data_HEADSHAPE_circlex : value = "circlex"; break; // X within circle (Unicode 1D145)        case data_HEADSHAPE_cross : value = "cross"; break; // plus sign (Unicode 1D144)        case data_HEADSHAPE_addslash : value = "addslash"; break; // added diagonal slash (/) through default note head        case data_HEADSHAPE_addbackslash (MusicXML) : value = "addbackslash (MusicXML)"; break; // added diagonal backslash (\) through default note head (MusicXML)        default:            LogWarning("Unknown Headshape '%d'", data);            value = "";            break;    }    return value;}data_HEADSHAPE Att::StrToHeadshape(std::string value){    if (value == "quarter") return data_HEADSHAPE_quarter; // filled oval (Unicode 1D158)    else if (value == "half") return data_HEADSHAPE_half; // open oval (Unicode 1D157)    else if (value == "whole") return data_HEADSHAPE_whole; // open oval (Unicode 1D15D)    else if (value == "dblwhole") return data_HEADSHAPE_dblwhole; // modern breve (Unicode 1D15C)    else if (value == "filldiamond") return data_HEADSHAPE_filldiamond; // filled diamond (Unicode 1D1BA)    else if (value == "diamond") return data_HEADSHAPE_diamond; // open diamond (Unicode 1D1B9)    else if (value == "dwdiamond") return data_HEADSHAPE_dwdiamond; // double whole diamond (Mup)    else if (value == "fillisotriangle") return data_HEADSHAPE_fillisotriangle; // filled isosceles triangle (Unicode 1D149)    else if (value == "isotriangle") return data_HEADSHAPE_isotriangle; // open isosceles triangle (Unicode 1D148)    else if (value == "dwhisotriangle") return data_HEADSHAPE_dwhisotriangle; // double whole open isosceles triangle (Unicode 1D14E)    else if (value == "fillpiewedge") return data_HEADSHAPE_fillpiewedge; // filled downward-pointing wedge (Unicode 1D155)    else if (value == "piewedge") return data_HEADSHAPE_piewedge; // downward-pointing wedge (Unicode 1D154)    else if (value == "dwhpiewedge") return data_HEADSHAPE_dwhpiewedge; // double whole downward-pointing wedge (Mup)    else if (value == "fillrectangle") return data_HEADSHAPE_fillrectangle; // filled rectangle (Unicode 1D147)    else if (value == "rectangle") return data_HEADSHAPE_rectangle; // open rectangle (Unicode 1D146)    else if (value == "dwhrectangle") return data_HEADSHAPE_dwhrectangle; // double whole open rectangle (Mup)    else if (value == "fillrtriangle") return data_HEADSHAPE_fillrtriangle; // filled right triangle (Unicode 1D14B)    else if (value == "rtriangle") return data_HEADSHAPE_rtriangle; // open right triangle (Unicode 1D14A)    else if (value == "dwrtriangle") return data_HEADSHAPE_dwrtriangle; // double whole right triangle (Mup)    else if (value == "fillurtriangle") return data_HEADSHAPE_fillurtriangle; // filled upper right triangle (Unicode 1D151)    else if (value == "urtriangle") return data_HEADSHAPE_urtriangle; // open upper right triangle (Unicode 1D150)    else if (value == "dwurtriangle") return data_HEADSHAPE_dwurtriangle; // double whole upper right triangle    else if (value == "fillsemicircle") return data_HEADSHAPE_fillsemicircle; // filled semi-circle (Unicode 1D153)    else if (value == "semicircle") return data_HEADSHAPE_semicircle; // open semi-circle (Unicode 1D152)    else if (value == "dwsemicircle") return data_HEADSHAPE_dwsemicircle; // double whole open semi-circle (Mup)    else if (value == "fillslash") return data_HEADSHAPE_fillslash; // filled slash (Mup)    else if (value == "slash") return data_HEADSHAPE_slash; // open slash (Mup)    else if (value == "dwslash") return data_HEADSHAPE_dwslash; // double whole open slash (Mup)    else if (value == "x") return data_HEADSHAPE_x; // X (Unicode 1D143)    else if (value == "blank") return data_HEADSHAPE_blank; // note head not rendered (Unicode 1D159)    else if (value == "circlex") return data_HEADSHAPE_circlex; // X within circle (Unicode 1D145)    else if (value == "cross") return data_HEADSHAPE_cross; // plus sign (Unicode 1D144)    else if (value == "addslash") return data_HEADSHAPE_addslash; // added diagonal slash (/) through default note head    else if (value == "addbackslash (MusicXML)") return data_HEADSHAPE_addbackslash (MusicXML); // added diagonal backslash (\) through default note head (MusicXML)    else {        LogWarning("Unknown Headshape '%s'", value.c_str() );    }    return HEADSHAPE_NONE;}std::string Att::IsodateToStr(data_ISODATE data){    std::string value;    switch(data)    {        default:            LogWarning("Unknown Isodate '%d'", data);            value = "";            break;    }    return value;}data_ISODATE Att::StrToIsodate(std::string value){    if (value == "") return data_ISODATE_; //     else {        LogWarning("Unknown Isodate '%s'", value.c_str() );    }    return ISODATE_NONE;}std::string Att::LayerschemeToStr(data_LAYERSCHEME data){    std::string value;    switch(data)    {        case data_LAYERSCHEME_1 : value = "1"; break; // single layer        case data_LAYERSCHEME_2o : value = "2o"; break; // two layers with opposing stems        case data_LAYERSCHEME_2f : value = "2f"; break; // two layers with 'floating' stems        case data_LAYERSCHEME_3o : value = "3o"; break; //         case data_LAYERSCHEME_3f : value = "3f"; break; //         default:            LogWarning("Unknown Layerscheme '%d'", data);            value = "";            break;    }    return value;}data_LAYERSCHEME Att::StrToLayerscheme(std::string value){    if (value == "1") return data_LAYERSCHEME_1; // single layer    else if (value == "2o") return data_LAYERSCHEME_2o; // two layers with opposing stems    else if (value == "2f") return data_LAYERSCHEME_2f; // two layers with 'floating' stems    else if (value == "3o") return data_LAYERSCHEME_3o; //     else if (value == "3f") return data_LAYERSCHEME_3f; //     else {        LogWarning("Unknown Layerscheme '%s'", value.c_str() );    }    return LAYERSCHEME_NONE;}std::string Att::LigatureformToStr(data_LIGATUREFORM data){    std::string value;    switch(data)    {        case data_LIGATUREFORM_recta : value = "recta"; break; // notes are "squeezed" together        case data_LIGATUREFORM_obliqua : value = "obliqua"; break; // individual notes are replaced by an oblique figure        default:            LogWarning("Unknown Ligatureform '%d'", data);            value = "";            break;    }    return value;}data_LIGATUREFORM Att::StrToLigatureform(std::string value){    if (value == "recta") return data_LIGATUREFORM_recta; // notes are "squeezed" together    else if (value == "obliqua") return data_LIGATUREFORM_obliqua; // individual notes are replaced by an oblique figure    else {        LogWarning("Unknown Ligatureform '%s'", value.c_str() );    }    return LIGATUREFORM_NONE;}std::string Att::LinerenditionToStr(data_LINERENDITION data){    std::string value;    switch(data)    {        case data_LINERENDITION_narrow : value = "narrow"; break; // default line width        case data_LINERENDITION_medium : value = "medium"; break; // twice as wide as narrow        case data_LINERENDITION_wide : value = "wide"; break; // twice as wide as medium        case data_LINERENDITION_dashed : value = "dashed"; break; // dashed line        case data_LINERENDITION_dotted : value = "dotted"; break; // dotted line        case data_LINERENDITION_wavy : value = "wavy"; break; // undulating line        default:            LogWarning("Unknown Linerendition '%d'", data);            value = "";            break;    }    return value;}data_LINERENDITION Att::StrToLinerendition(std::string value){    if (value == "narrow") return data_LINERENDITION_narrow; // default line width    else if (value == "medium") return data_LINERENDITION_medium; // twice as wide as narrow    else if (value == "wide") return data_LINERENDITION_wide; // twice as wide as medium    else if (value == "dashed") return data_LINERENDITION_dashed; // dashed line    else if (value == "dotted") return data_LINERENDITION_dotted; // dotted line    else if (value == "wavy") return data_LINERENDITION_wavy; // undulating line    else {        LogWarning("Unknown Linerendition '%s'", value.c_str() );    }    return LINERENDITION_NONE;}std::string Att::MensurationsignToStr(data_MENSURATIONSIGN data){    std::string value;    switch(data)    {        case data_MENSURATIONSIGN_C : value = "C"; break; // tempus imperfectum        case data_MENSURATIONSIGN_O : value = "O"; break; // tempus perfectum        default:            LogWarning("Unknown Mensurationsign '%d'", data);            value = "";            break;    }    return value;}data_MENSURATIONSIGN Att::StrToMensurationsign(std::string value){    if (value == "C") return data_MENSURATIONSIGN_C; // tempus imperfectum    else if (value == "O") return data_MENSURATIONSIGN_O; // tempus perfectum    else {        LogWarning("Unknown Mensurationsign '%s'", value.c_str() );    }    return MENSURATIONSIGN_NONE;}std::string Att::MetersignToStr(data_METERSIGN data){    std::string value;    switch(data)    {        case data_METERSIGN_common : value = "common"; break; // common time; i.e. 4/4        case data_METERSIGN_cut : value = "cut"; break; // cut time; i.e. 2/2        default:            LogWarning("Unknown Metersign '%d'", data);            value = "";            break;    }    return value;}data_METERSIGN Att::StrToMetersign(std::string value){    if (value == "common") return data_METERSIGN_common; // common time; i.e. 4/4    else if (value == "cut") return data_METERSIGN_cut; // cut time; i.e. 2/2    else {        LogWarning("Unknown Metersign '%s'", value.c_str() );    }    return METERSIGN_NONE;}std::string Att::ModeToStr(data_MODE data){    std::string value;    switch(data)    {        case data_MODE_major : value = "major"; break; //         case data_MODE_minor : value = "minor"; break; //         case data_MODE_dorian : value = "dorian"; break; //         case data_MODE_phrygian : value = "phrygian"; break; //         case data_MODE_lydian : value = "lydian"; break; //         case data_MODE_mixolydian : value = "mixolydian"; break; //         case data_MODE_aeolian : value = "aeolian"; break; //         case data_MODE_locrian : value = "locrian"; break; //         default:            LogWarning("Unknown Mode '%d'", data);            value = "";            break;    }    return value;}data_MODE Att::StrToMode(std::string value){    if (value == "major") return data_MODE_major; //     else if (value == "minor") return data_MODE_minor; //     else if (value == "dorian") return data_MODE_dorian; //     else if (value == "phrygian") return data_MODE_phrygian; //     else if (value == "lydian") return data_MODE_lydian; //     else if (value == "mixolydian") return data_MODE_mixolydian; //     else if (value == "aeolian") return data_MODE_aeolian; //     else if (value == "locrian") return data_MODE_locrian; //     else {        LogWarning("Unknown Mode '%s'", value.c_str() );    }    return MODE_NONE;}std::string Att::OtherstaffToStr(data_OTHERSTAFF data){    std::string value;    switch(data)    {        case data_OTHERSTAFF_above : value = "above"; break; //         case data_OTHERSTAFF_below : value = "below"; break; //         default:            LogWarning("Unknown Otherstaff '%d'", data);            value = "";            break;    }    return value;}data_OTHERSTAFF Att::StrToOtherstaff(std::string value){    if (value == "above") return data_OTHERSTAFF_above; //     else if (value == "below") return data_OTHERSTAFF_below; //     else {        LogWarning("Unknown Otherstaff '%s'", value.c_str() );    }    return OTHERSTAFF_NONE;}std::string Att::PgscaleToStr(data_PGSCALE data){    std::string value;    switch(data)    {        default:            LogWarning("Unknown Pgscale '%d'", data);            value = "";            break;    }    return value;}data_PGSCALE Att::StrToPgscale(std::string value){    if (value == "") return data_PGSCALE_; //     else {        LogWarning("Unknown Pgscale '%s'", value.c_str() );    }    return PGSCALE_NONE;}std::string Att::PlaceToStr(data_PLACE data){    std::string value;    switch(data)    {        case data_PLACE_above : value = "above"; break; //         case data_PLACE_below : value = "below"; break; //         default:            LogWarning("Unknown Place '%d'", data);            value = "";            break;    }    return value;}data_PLACE Att::StrToPlace(std::string value){    if (value == "above") return data_PLACE_above; //     else if (value == "below") return data_PLACE_below; //     else {        LogWarning("Unknown Place '%s'", value.c_str() );    }    return PLACE_NONE;}std::string Att::SizeToStr(data_SIZE data){    std::string value;    switch(data)    {        case data_SIZE_normal : value = "normal"; break; // default size        case data_SIZE_cue : value = "cue"; break; // reduced size        default:            LogWarning("Unknown Size '%d'", data);            value = "";            break;    }    return value;}data_SIZE Att::StrToSize(std::string value){    if (value == "normal") return data_SIZE_normal; // default size    else if (value == "cue") return data_SIZE_cue; // reduced size    else {        LogWarning("Unknown Size '%s'", value.c_str() );    }    return SIZE_NONE;}std::string Att::StaffrelToStr(data_STAFFREL data){    std::string value;    switch(data)    {        case data_STAFFREL_above : value = "above"; break; // written above staff        case data_STAFFREL_below : value = "below"; break; // written below staff        case data_STAFFREL_within : value = "within"; break; // written on staff        default:            LogWarning("Unknown Staffrel '%d'", data);            value = "";            break;    }    return value;}data_STAFFREL Att::StrToStaffrel(std::string value){    if (value == "above") return data_STAFFREL_above; // written above staff    else if (value == "below") return data_STAFFREL_below; // written below staff    else if (value == "within") return data_STAFFREL_within; // written on staff    else {        LogWarning("Unknown Staffrel '%s'", value.c_str() );    }    return STAFFREL_NONE;}std::string Att::StemdirectionToStr(data_STEMDIRECTION data){    std::string value;    switch(data)    {        case data_STEMDIRECTION_up : value = "up"; break; // stem points upward        case data_STEMDIRECTION_down : value = "down"; break; // stem points downward        default:            LogWarning("Unknown Stemdirection '%d'", data);            value = "";            break;    }    return value;}data_STEMDIRECTION Att::StrToStemdirection(std::string value){    if (value == "up") return data_STEMDIRECTION_up; // stem points upward    else if (value == "down") return data_STEMDIRECTION_down; // stem points downward    else {        LogWarning("Unknown Stemdirection '%s'", value.c_str() );    }    return STEMDIRECTION_NONE;}std::string Att::StemmodifierToStr(data_STEMMODIFIER data){    std::string value;    switch(data)    {        case data_STEMMODIFIER_1slash : value = "1slash"; break; // 1 slash through stem        case data_STEMMODIFIER_2slash : value = "2slash"; break; // 2 slashes through stem        case data_STEMMODIFIER_3slash : value = "3slash"; break; // 3 slashes through stem        case data_STEMMODIFIER_4slash : value = "4slash"; break; // 4 slashes through stem        case data_STEMMODIFIER_5slash : value = "5slash"; break; // 5 slashes through stem        case data_STEMMODIFIER_6slash : value = "6slash"; break; // 6 slashes through stem        case data_STEMMODIFIER_sprech : value = "sprech"; break; // X placed on stem        case data_STEMMODIFIER_z : value = "z"; break; // Z placed on stem        default:            LogWarning("Unknown Stemmodifier '%d'", data);            value = "";            break;    }    return value;}data_STEMMODIFIER Att::StrToStemmodifier(std::string value){    if (value == "1slash") return data_STEMMODIFIER_1slash; // 1 slash through stem    else if (value == "2slash") return data_STEMMODIFIER_2slash; // 2 slashes through stem    else if (value == "3slash") return data_STEMMODIFIER_3slash; // 3 slashes through stem    else if (value == "4slash") return data_STEMMODIFIER_4slash; // 4 slashes through stem    else if (value == "5slash") return data_STEMMODIFIER_5slash; // 5 slashes through stem    else if (value == "6slash") return data_STEMMODIFIER_6slash; // 6 slashes through stem    else if (value == "sprech") return data_STEMMODIFIER_sprech; // X placed on stem    else if (value == "z") return data_STEMMODIFIER_z; // Z placed on stem    else {        LogWarning("Unknown Stemmodifier '%s'", value.c_str() );    }    return STEMMODIFIER_NONE;}std::string Att::StempositionToStr(data_STEMPOSITION data){    std::string value;    switch(data)    {        case data_STEMPOSITION_left : value = "left"; break; // stem attached to left side of note head        case data_STEMPOSITION_right : value = "right"; break; // stem attached to right side of note head        case data_STEMPOSITION_center : value = "center"; break; // stem is originates from center of note head        default:            LogWarning("Unknown Stemposition '%d'", data);            value = "";            break;    }    return value;}data_STEMPOSITION Att::StrToStemposition(std::string value){    if (value == "left") return data_STEMPOSITION_left; // stem attached to left side of note head    else if (value == "right") return data_STEMPOSITION_right; // stem attached to right side of note head    else if (value == "center") return data_STEMPOSITION_center; // stem is originates from center of note head    else {        LogWarning("Unknown Stemposition '%s'", value.c_str() );    }    return STEMPOSITION_NONE;}std::string Att::TemperamentToStr(data_TEMPERAMENT data){    std::string value;    switch(data)    {        case data_TEMPERAMENT_equal : value = "equal"; break; // equal or 12-tone temperament        case data_TEMPERAMENT_just : value = "just"; break; // just intonation        case data_TEMPERAMENT_mean : value = "mean"; break; // meantone intonation        case data_TEMPERAMENT_pythagorean : value = "pythagorean"; break; // pythagorean tuning        default:            LogWarning("Unknown Temperament '%d'", data);            value = "";            break;    }    return value;}data_TEMPERAMENT Att::StrToTemperament(std::string value){    if (value == "equal") return data_TEMPERAMENT_equal; // equal or 12-tone temperament    else if (value == "just") return data_TEMPERAMENT_just; // just intonation    else if (value == "mean") return data_TEMPERAMENT_mean; // meantone intonation    else if (value == "pythagorean") return data_TEMPERAMENT_pythagorean; // pythagorean tuning    else {        LogWarning("Unknown Temperament '%s'", value.c_str() );    }    return TEMPERAMENT_NONE;}std::string Att::MacroMusicpartToStr(macro_musicPart data){    std::string value;    switch(data)    {        default:            LogWarning("Unknown MacroMusicpart '%d'", data);            value = "";            break;    }    return value;}macro_musicPart Att::StrToMacroMusicpart(std::string value){    if (value == "") return macro_musicPart_; //     else {        LogWarning("Unknown MacroMusicpart '%s'", value.c_str() );    }    return macro_musicPart_NONE;}std::string Att::BeamRendToStr(data_BEAM_REND data){    std::string value;    switch(data) || $lb    {        case data_BEAM_REND_acc : value = "acc"; break; // beams lines grow farther apart from left to right.        case data_BEAM_REND_rit : value = "rit"; break; // beam lines grow closer together from left to right.        case data_BEAM_REND_norm : value = "norm"; break; // beam lines are equally-spaced over the entire length of the beam.        default:            LogWarning("Unknown BeamRend '%d'", data);            value = "";            break;    }    return value;}data_BEAM_REND Att::StrToBeamRend(std::string value){    if (value == "acc") return data_BEAM_REND_acc; // beams lines grow farther apart from left to right.    else if (value == "rit") return data_BEAM_REND_rit; // beam lines grow closer together from left to right.    else if (value == "norm") return data_BEAM_REND_norm; // beam lines are equally-spaced over the entire length of the beam.    else {        LogWarning("Unknown BeamRend '%s'", value.c_str() );    }    return BEAM_REND_NONE;}std::string Att::CurvedirToStr(data_CURVEDIR data){    std::string value;    switch(data) || $lb    {        case data_CURVEDIR_above : value = "above"; break; // upward curve.        case data_CURVEDIR_below : value = "below"; break; // downward curve.        default:            LogWarning("Unknown Curvedir '%d'", data);            value = "";            break;    }    return value;}data_CURVEDIR Att::StrToCurvedir(std::string value){    if (value == "above") return data_CURVEDIR_above; // upward curve.    else if (value == "below") return data_CURVEDIR_below; // downward curve.    else {        LogWarning("Unknown Curvedir '%s'", value.c_str() );    }    return CURVEDIR_NONE;}std::string Att::FormToStr(data_FORM data){    std::string value;    switch(data) || $lb    {        case data_FORM_aug : value = "aug"; break; // augmentation dot.        case data_FORM_div : value = "div"; break; // dot of division.        default:            LogWarning("Unknown Form '%d'", data);            value = "";            break;    }    return value;}data_FORM Att::StrToForm(std::string value){    if (value == "aug") return data_FORM_aug; // augmentation dot.    else if (value == "div") return data_FORM_div; // dot of division.    else {        LogWarning("Unknown Form '%s'", value.c_str() );    }    return FORM_NONE;}std::string Att::HalignToStr(data_HALIGN data){    std::string value;    switch(data) || $lb    {        case data_HALIGN_left : value = "left"; break; // left aligned.        case data_HALIGN_right : value = "right"; break; // right aligned.        case data_HALIGN_center : value = "center"; break; // centered.        case data_HALIGN_justify : value = "justify"; break; // left and right aligned.        default:            LogWarning("Unknown Halign '%d'", data);            value = "";            break;    }    return value;}data_HALIGN Att::StrToHalign(std::string value){    if (value == "left") return data_HALIGN_left; // left aligned.    else if (value == "right") return data_HALIGN_right; // right aligned.    else if (value == "center") return data_HALIGN_center; // centered.    else if (value == "justify") return data_HALIGN_justify; // left and right aligned.    else {        LogWarning("Unknown Halign '%s'", value.c_str() );    }    return HALIGN_NONE;}std::string Att::UnitToStr(data_UNIT data){    std::string value;    switch(data) || $lb    {        case data_UNIT_cm : value = "cm"; break; // centimeter.        case data_UNIT_mm : value = "mm"; break; // millimeter.        case data_UNIT_in : value = "in"; break; // inch.        case data_UNIT_issue : value = "issue"; break; // serial issue.        case data_UNIT_page : value = "page"; break; // page.        case data_UNIT_px : value = "px"; break; // pixel.        case data_UNIT_pt : value = "pt"; break; // point.        case data_UNIT_pc : value = "pc"; break; // pica.        case data_UNIT_vu : value = "vu"; break; // MEI virtual unit.        case data_UNIT_vol : value = "vol"; break; // serial volume.        default:            LogWarning("Unknown Unit '%d'", data);            value = "";            break;    }    return value;}data_UNIT Att::StrToUnit(std::string value){    if (value == "cm") return data_UNIT_cm; // centimeter.    else if (value == "mm") return data_UNIT_mm; // millimeter.    else if (value == "in") return data_UNIT_in; // inch.    else if (value == "issue") return data_UNIT_issue; // serial issue.    else if (value == "page") return data_UNIT_page; // page.    else if (value == "px") return data_UNIT_px; // pixel.    else if (value == "pt") return data_UNIT_pt; // point.    else if (value == "pc") return data_UNIT_pc; // pica.    else if (value == "vu") return data_UNIT_vu; // MEI virtual unit.    else if (value == "vol") return data_UNIT_vol; // serial volume.    else {        LogWarning("Unknown Unit '%s'", value.c_str() );    }    return UNIT_NONE;}std::string Att::MeiversionToStr(data_MEIVERSION data){    std::string value;    switch(data) || $lb    {        case data_MEIVERSION_2013 : value = "2013"; break; // this version of MEI.        default:            LogWarning("Unknown Meiversion '%d'", data);            value = "";            break;    }    return value;}data_MEIVERSION Att::StrToMeiversion(std::string value){    if (value == "2013") return data_MEIVERSION_2013; // this version of MEI.    else {        LogWarning("Unknown Meiversion '%s'", value.c_str() );    }    return MEIVERSION_NONE;}std::string Att::MeiversionNumToStr(data_MEIVERSION_NUM data){    std::string value;    switch(data) || $lb    {        case data_MEIVERSION_NUM_2.1.1 : value = "2.1.1"; break; // this version of MEI.        default:            LogWarning("Unknown MeiversionNum '%d'", data);            value = "";            break;    }    return value;}data_MEIVERSION_NUM Att::StrToMeiversionNum(std::string value){    if (value == "2.1.1") return data_MEIVERSION_NUM_2.1.1; // this version of MEI.    else {        LogWarning("Unknown MeiversionNum '%s'", value.c_str() );    }    return MEIVERSION_NUM_NONE;}std::string Att::MetconToStr(data_METCON data){    std::string value;    switch(data) || $lb    {        case data_METCON_c : value = "c"; break; // conformant with the prevailing meter.        case data_METCON_i : value = "i"; break; // incomplete; i.e., not enough beats.        case data_METCON_o : value = "o"; break; // overfull; i.e., too many beats.        default:            LogWarning("Unknown Metcon '%d'", data);            value = "";            break;    }    return value;}data_METCON Att::StrToMetcon(std::string value){    if (value == "c") return data_METCON_c; // conformant with the prevailing meter.    else if (value == "i") return data_METCON_i; // incomplete; i.e., not enough beats.    else if (value == "o") return data_METCON_o; // overfull; i.e., too many beats.    else {        LogWarning("Unknown Metcon '%s'", value.c_str() );    }    return METCON_NONE;}std::string Att::RendToStr(data_REND data){    std::string value;    switch(data) || $lb    {        case data_REND_num : value = "num"; break; // show only the number of beats.        case data_REND_denomsym : value = "denomsym"; break; // the lower number in the meter signature is replaced by a note symbol.        case data_REND_norm : value = "norm"; break; // meter signature rendered using traditional numeric values.        case data_REND_invis : value = "invis"; break; // meter signature not rendered.        default:            LogWarning("Unknown Rend '%d'", data);            value = "";            break;    }    return value;}data_REND Att::StrToRend(std::string value){    if (value == "num") return data_REND_num; // show only the number of beats.    else if (value == "denomsym") return data_REND_denomsym; // the lower number in the meter signature is replaced by a note symbol.    else if (value == "norm") return data_REND_norm; // meter signature rendered using traditional numeric values.    else if (value == "invis") return data_REND_invis; // meter signature not rendered.    else {        LogWarning("Unknown Rend '%s'", value.c_str() );    }    return REND_NONE;}std::string Att::MeterRendToStr(data_METER_REND data){    std::string value;    switch(data) || $lb    {        case data_METER_REND_num : value = "num"; break; // show only the number of beats.        case data_METER_REND_denomsym : value = "denomsym"; break; // the lower number in the meter signature is replaced by a note symbol.        case data_METER_REND_norm : value = "norm"; break; // meter signature rendered using traditional numeric values.        case data_METER_REND_invis : value = "invis"; break; // meter signature not rendered.        default:            LogWarning("Unknown MeterRend '%d'", data);            value = "";            break;    }    return value;}data_METER_REND Att::StrToMeterRend(std::string value){    if (value == "num") return data_METER_REND_num; // show only the number of beats.    else if (value == "denomsym") return data_METER_REND_denomsym; // the lower number in the meter signature is replaced by a note symbol.    else if (value == "norm") return data_METER_REND_norm; // meter signature rendered using traditional numeric values.    else if (value == "invis") return data_METER_REND_invis; // meter signature not rendered.    else {        LogWarning("Unknown MeterRend '%s'", value.c_str() );    }    return METER_REND_NONE;}std::string Att::FuncToStr(data_FUNC data){    std::string value;    switch(data) || $lb    {        case data_FUNC_verso : value = "verso"; break; //         case data_FUNC_recto : value = "recto"; break; //         default:            LogWarning("Unknown Func '%d'", data);            value = "";            break;    }    return value;}data_FUNC Att::StrToFunc(std::string value){    if (value == "verso") return data_FUNC_verso; //     else if (value == "recto") return data_FUNC_recto; //     else {        LogWarning("Unknown Func '%s'", value.c_str() );    }    return FUNC_NONE;}std::string Att::EvaluateToStr(data_EVALUATE data){    std::string value;    switch(data) || $lb    {        case data_EVALUATE_all : value = "all"; break; // if the element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.        case data_EVALUATE_one : value = "one"; break; // if the element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.        case data_EVALUATE_none : value = "none"; break; // no further evaluation of targets is carried out beyond that needed to find the element specified in the pointer's target.        default:            LogWarning("Unknown Evaluate '%d'", data);            value = "";            break;    }    return value;}data_EVALUATE Att::StrToEvaluate(std::string value){    if (value == "all") return data_EVALUATE_all; // if the element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.    else if (value == "one") return data_EVALUATE_one; // if the element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.    else if (value == "none") return data_EVALUATE_none; // no further evaluation of targets is carried out beyond that needed to find the element specified in the pointer's target.    else {        LogWarning("Unknown Evaluate '%s'", value.c_str() );    }    return EVALUATE_NONE;}std::string Att::Xlink:actuateToStr(data_XLINK:ACTUATE data){    std::string value;    switch(data) || $lb    {        case data_XLINK:ACTUATE_onLoad : value = "onLoad"; break; // load the target resource immediately.        case data_XLINK:ACTUATE_onRequest : value = "onRequest"; break; // load the target resource upon user request.        case data_XLINK:ACTUATE_none : value = "none"; break; // do not permit loading of the target resource.        case data_XLINK:ACTUATE_other : value = "other"; break; // behavior other than allowed by the other values of this attribute.        default:            LogWarning("Unknown Xlink:actuate '%d'", data);            value = "";            break;    }    return value;}data_XLINK:ACTUATE Att::StrToXlink:actuate(std::string value){    if (value == "onLoad") return data_XLINK:ACTUATE_onLoad; // load the target resource immediately.    else if (value == "onRequest") return data_XLINK:ACTUATE_onRequest; // load the target resource upon user request.    else if (value == "none") return data_XLINK:ACTUATE_none; // do not permit loading of the target resource.    else if (value == "other") return data_XLINK:ACTUATE_other; // behavior other than allowed by the other values of this attribute.    else {        LogWarning("Unknown Xlink:actuate '%s'", value.c_str() );    }    return XLINK:ACTUATE_NONE;}std::string Att::Xlink:showToStr(data_XLINK:SHOW data){    std::string value;    switch(data) || $lb    {        case data_XLINK:SHOW_new : value = "new"; break; // open in a new window.        case data_XLINK:SHOW_replace : value = "replace"; break; // load the referenced resource in the same window.        case data_XLINK:SHOW_embed : value = "embed"; break; // embed the referenced resource at the point of the link.        case data_XLINK:SHOW_none : value = "none"; break; // do not permit traversal to the referenced resource.        case data_XLINK:SHOW_other : value = "other"; break; // behavior other than permitted by the other values of this attribute.        default:            LogWarning("Unknown Xlink:show '%d'", data);            value = "";            break;    }    return value;}data_XLINK:SHOW Att::StrToXlink:show(std::string value){    if (value == "new") return data_XLINK:SHOW_new; // open in a new window.    else if (value == "replace") return data_XLINK:SHOW_replace; // load the referenced resource in the same window.    else if (value == "embed") return data_XLINK:SHOW_embed; // embed the referenced resource at the point of the link.    else if (value == "none") return data_XLINK:SHOW_none; // do not permit traversal to the referenced resource.    else if (value == "other") return data_XLINK:SHOW_other; // behavior other than permitted by the other values of this attribute.    else {        LogWarning("Unknown Xlink:show '%s'", value.c_str() );    }    return XLINK:SHOW_NONE;}std::string Att::RendToStr(data_REND data){    std::string value;    switch(data) || $lb    {        case data_REND_hash : value = "hash"; break; // display hash marks between systems.        default:            LogWarning("Unknown Rend '%d'", data);            value = "";            break;    }    return value;}data_REND Att::StrToRend(std::string value){    if (value == "hash") return data_REND_hash; // display hash marks between systems.    else {        LogWarning("Unknown Rend '%s'", value.c_str() );    }    return REND_NONE;}std::string Att::EndingRendToStr(data_ENDING_REND data){    std::string value;    switch(data) || $lb    {        case data_ENDING_REND_top : value = "top"; break; // ending rendered only above top staff.        case data_ENDING_REND_barred : value = "barred"; break; // ending rendered above staves that have bar lines drawn across them.        case data_ENDING_REND_grouped : value = "grouped"; break; // endings rendered above staff groups.        default:            LogWarning("Unknown EndingRend '%d'", data);            value = "";            break;    }    return value;}data_ENDING_REND Att::StrToEndingRend(std::string value){    if (value == "top") return data_ENDING_REND_top; // ending rendered only above top staff.    else if (value == "barred") return data_ENDING_REND_barred; // ending rendered above staves that have bar lines drawn across them.    else if (value == "grouped") return data_ENDING_REND_grouped; // endings rendered above staff groups.    else {        LogWarning("Unknown EndingRend '%s'", value.c_str() );    }    return ENDING_REND_NONE;}std::string Att::SymbolToStr(data_SYMBOL data){    std::string value;    switch(data) || $lb    {        case data_SYMBOL_brace : value = "brace"; break; // curved symbol, i.e., {.        case data_SYMBOL_bracket : value = "bracket"; break; // square symbol, i.e., [.        case data_SYMBOL_line : value = "line"; break; // line symbol, i.e., |.        case data_SYMBOL_none : value = "none"; break; // grouping symbol missing.        default:            LogWarning("Unknown Symbol '%d'", data);            value = "";            break;    }    return value;}data_SYMBOL Att::StrToSymbol(std::string value){    if (value == "brace") return data_SYMBOL_brace; // curved symbol, i.e., {.    else if (value == "bracket") return data_SYMBOL_bracket; // square symbol, i.e., [.    else if (value == "line") return data_SYMBOL_line; // line symbol, i.e., |.    else if (value == "none") return data_SYMBOL_none; // grouping symbol missing.    else {        LogWarning("Unknown Symbol '%s'", value.c_str() );    }    return SYMBOL_NONE;}std::string Att::ConToStr(data_CON data){    std::string value;    switch(data) || $lb    {        case data_CON_s : value = "s"; break; // space (word separator).        case data_CON_d : value = "d"; break; // dash (syllable separator).        case data_CON_u : value = "u"; break; // underscore (syllable extension).        case data_CON_t : value = "t"; break; // tilde (syllable elision).        case data_CON_c : value = "c"; break; // circumflex [angled line above] (syllable elision).        case data_CON_v : value = "v"; break; // caron [angled line below] (syllable elision).        case data_CON_i : value = "i"; break; // inverted breve [curved line above] (syllable elision).        case data_CON_b : value = "b"; break; // breve [curved line below] (syllable elision).        default:            LogWarning("Unknown Con '%d'", data);            value = "";            break;    }    return value;}data_CON Att::StrToCon(std::string value){    if (value == "s") return data_CON_s; // space (word separator).    else if (value == "d") return data_CON_d; // dash (syllable separator).    else if (value == "u") return data_CON_u; // underscore (syllable extension).    else if (value == "t") return data_CON_t; // tilde (syllable elision).    else if (value == "c") return data_CON_c; // circumflex [angled line above] (syllable elision).    else if (value == "v") return data_CON_v; // caron [angled line below] (syllable elision).    else if (value == "i") return data_CON_i; // inverted breve [curved line above] (syllable elision).    else if (value == "b") return data_CON_b; // breve [curved line below] (syllable elision).    else {        LogWarning("Unknown Con '%s'", value.c_str() );    }    return CON_NONE;}std::string Att::WordposToStr(data_WORDPOS data){    std::string value;    switch(data) || $lb    {        case data_WORDPOS_i : value = "i"; break; // (initial) first syllable.        case data_WORDPOS_m : value = "m"; break; // (medial) neither first nor last syllable.        case data_WORDPOS_t : value = "t"; break; // (terminal) last syllable.        default:            LogWarning("Unknown Wordpos '%d'", data);            value = "";            break;    }    return value;}data_WORDPOS Att::StrToWordpos(std::string value){    if (value == "i") return data_WORDPOS_i; // (initial) first syllable.    else if (value == "m") return data_WORDPOS_m; // (medial) neither first nor last syllable.    else if (value == "t") return data_WORDPOS_t; // (terminal) last syllable.    else {        LogWarning("Unknown Wordpos '%s'", value.c_str() );    }    return WORDPOS_NONE;}std::string Att::Xml:spaceToStr(data_XML:SPACE data){    std::string value;    switch(data) || $lb    {        case data_XML:SPACE_default : value = "default"; break; // allows the application to handle white space as necessary. Not including an xml:space attribute produces the same result as using the default value.        case data_XML:SPACE_preserve : value = "preserve"; break; // instructs the application to maintain white space "as-is", suggesting that it might have meaning.        default:            LogWarning("Unknown Xml:space '%d'", data);            value = "";            break;    }    return value;}data_XML:SPACE Att::StrToXml:space(std::string value){    if (value == "default") return data_XML:SPACE_default; // allows the application to handle white space as necessary. Not including an xml:space attribute produces the same result as using the default value.    else if (value == "preserve") return data_XML:SPACE_preserve; // instructs the application to maintain white space "as-is", suggesting that it might have meaning.    else {        LogWarning("Unknown Xml:space '%s'", value.c_str() );    }    return XML:SPACE_NONE;}std::string Att::RelToStr(data_REL data){    std::string value;    switch(data) || $lb    {        case data_REL_preceding : value = "preceding"; break; // predecessor of the resource        case data_REL_succeeding : value = "succeeding"; break; // successor to the resource        case data_REL_original : value = "original"; break; // original form of the resource        case data_REL_host : value = "host"; break; // parent containing the resource        case data_REL_constituent : value = "constituent"; break; // intellectual or physical component of the resource        case data_REL_otherVersion : value = "otherVersion"; break; // version of the resource's intellectual content not changed enough to be a different work        case data_REL_otherFormat : value = "otherFormat"; break; // version of the resource in a different physical format        case data_REL_isReferencedBy : value = "isReferencedBy"; break; // published bibliographic description, review, abstract, or index of the resource's content        case data_REL_references : value = "references"; break; // cited or referred to in the resource        default:            LogWarning("Unknown Rel '%d'", data);            value = "";            break;    }    return value;}data_REL Att::StrToRel(std::string value){    if (value == "preceding") return data_REL_preceding; // predecessor of the resource    else if (value == "succeeding") return data_REL_succeeding; // successor to the resource    else if (value == "original") return data_REL_original; // original form of the resource    else if (value == "host") return data_REL_host; // parent containing the resource    else if (value == "constituent") return data_REL_constituent; // intellectual or physical component of the resource    else if (value == "otherVersion") return data_REL_otherVersion; // version of the resource's intellectual content not changed enough to be a different work    else if (value == "otherFormat") return data_REL_otherFormat; // version of the resource in a different physical format    else if (value == "isReferencedBy") return data_REL_isReferencedBy; // published bibliographic description, review, abstract, or index of the resource's content    else if (value == "references") return data_REL_references; // cited or referred to in the resource    else {        LogWarning("Unknown Rel '%s'", value.c_str() );    }    return REL_NONE;}std::string Att::MethodToStr(data_METHOD data){    std::string value;    switch(data) || $lb    {        case data_METHOD_silent : value = "silent"; break; // corrections and normalizations made silently.        case data_METHOD_tags : value = "tags"; break; // corrections and normalizations indicated using elements.        default:            LogWarning("Unknown Method '%d'", data);            value = "";            break;    }    return value;}data_METHOD Att::StrToMethod(std::string value){    if (value == "silent") return data_METHOD_silent; // corrections and normalizations made silently.    else if (value == "tags") return data_METHOD_tags; // corrections and normalizations indicated using elements.    else {        LogWarning("Unknown Method '%s'", value.c_str() );    }    return METHOD_NONE;}std::string Att::CorrlevelToStr(data_CORRLEVEL data){    std::string value;    switch(data) || $lb    {        case data_CORRLEVEL_high : value = "high"; break; // the text has been thoroughly checked and proofread.        case data_CORRLEVEL_medium : value = "medium"; break; // the text has been checked at least once.        case data_CORRLEVEL_low : value = "low"; break; // the text has not been checked.        case data_CORRLEVEL_unknown : value = "unknown"; break; // the correction status of the text is unknown.        default:            LogWarning("Unknown Corrlevel '%d'", data);            value = "";            break;    }    return value;}data_CORRLEVEL Att::StrToCorrlevel(std::string value){    if (value == "high") return data_CORRLEVEL_high; // the text has been thoroughly checked and proofread.    else if (value == "medium") return data_CORRLEVEL_medium; // the text has been checked at least once.    else if (value == "low") return data_CORRLEVEL_low; // the text has not been checked.    else if (value == "unknown") return data_CORRLEVEL_unknown; // the correction status of the text is unknown.    else {        LogWarning("Unknown Corrlevel '%s'", value.c_str() );    }    return CORRLEVEL_NONE;}std::string Att::FormToStr(data_FORM data){    std::string value;    switch(data) || $lb    {        case data_FORM_plaineAndEasie : value = "plaineAndEasie"; break; // Plaine & Easie Code.        case data_FORM_humdrumKern : value = "humdrumKern"; break; // Humdrum Kern format.        case data_FORM_parsons : value = "parsons"; break; // Parsons code.        default:            LogWarning("Unknown Form '%d'", data);            value = "";            break;    }    return value;}data_FORM Att::StrToForm(std::string value){    if (value == "plaineAndEasie") return data_FORM_plaineAndEasie; // Plaine & Easie Code.    else if (value == "humdrumKern") return data_FORM_humdrumKern; // Humdrum Kern format.    else if (value == "parsons") return data_FORM_parsons; // Parsons code.    else {        LogWarning("Unknown Form '%s'", value.c_str() );    }    return FORM_NONE;}std::string Att::TypeToStr(data_TYPE data){    std::string value;    switch(data) || $lb    {        case data_TYPE_music : value = "music"; break; // header is attached to a music document.        case data_TYPE_corpus : value = "corpus"; break; // header is attached to a corpus.        default:            LogWarning("Unknown Type '%d'", data);            value = "";            break;    }    return value;}data_TYPE Att::StrToType(std::string value){    if (value == "music") return data_TYPE_music; // header is attached to a music document.    else if (value == "corpus") return data_TYPE_corpus; // header is attached to a corpus.    else {        LogWarning("Unknown Type '%s'", value.c_str() );    }    return TYPE_NONE;}std::string Att::RendToStr(data_REND data){    std::string value;    switch(data) || $lb    {        case data_REND_acc : value = "acc"; break; // (accelerando) indicates that the secondary beams get progressively closer together toward the end of the beam.        case data_REND_mixed : value = "mixed"; break; // (mixed acc and rit) for beams that are "feathered" in both directions.        case data_REND_rit : value = "rit"; break; // (ritardando) means that the secondary beams become progressively more distance toward the end of the beam.        case data_REND_norm : value = "norm"; break; // (normal) indicates that the secondary beams are equidistant along the course of the beam.        default:            LogWarning("Unknown Rend '%d'", data);            value = "";            break;    }    return value;}data_REND Att::StrToRend(std::string value){    if (value == "acc") return data_REND_acc; // (accelerando) indicates that the secondary beams get progressively closer together toward the end of the beam.    else if (value == "mixed") return data_REND_mixed; // (mixed acc and rit) for beams that are "feathered" in both directions.    else if (value == "rit") return data_REND_rit; // (ritardando) means that the secondary beams become progressively more distance toward the end of the beam.    else if (value == "norm") return data_REND_norm; // (normal) indicates that the secondary beams are equidistant along the course of the beam.    else {        LogWarning("Unknown Rend '%s'", value.c_str() );    }    return REND_NONE;}std::string Att::CutoutToStr(data_CUTOUT data){    std::string value;    switch(data) || $lb    {        case data_CUTOUT_cutout : value = "cutout"; break; // the staff lines should not be drawn.        default:            LogWarning("Unknown Cutout '%d'", data);            value = "";            break;    }    return value;}data_CUTOUT Att::StrToCutout(std::string value){    if (value == "cutout") return data_CUTOUT_cutout; // the staff lines should not be drawn.    else {        LogWarning("Unknown Cutout '%s'", value.c_str() );    }    return CUTOUT_NONE;}std::string Att::FormToStr(data_FORM data){    std::string value;    switch(data) || $lb    {        case data_FORM_inv : value = "inv"; break; // inverted, i.e., curve or bracket below the dot.        case data_FORM_norm : value = "norm"; break; // upright; i.e., curve or bracket above the dot.        default:            LogWarning("Unknown Form '%d'", data);            value = "";            break;    }    return value;}data_FORM Att::StrToForm(std::string value){    if (value == "inv") return data_FORM_inv; // inverted, i.e., curve or bracket below the dot.    else if (value == "norm") return data_FORM_norm; // upright; i.e., curve or bracket above the dot.    else {        LogWarning("Unknown Form '%s'", value.c_str() );    }    return FORM_NONE;}std::string Att::ShapeToStr(data_SHAPE data){    std::string value;    switch(data) || $lb    {        case data_SHAPE_curved : value = "curved"; break; // a curve above or below the dot.        case data_SHAPE_square : value = "square"; break; // a bracket above or below the dot.        default:            LogWarning("Unknown Shape '%d'", data);            value = "";            break;    }    return value;}data_SHAPE Att::StrToShape(std::string value){    if (value == "curved") return data_SHAPE_curved; // a curve above or below the dot.    else if (value == "square") return data_SHAPE_square; // a bracket above or below the dot.    else {        LogWarning("Unknown Shape '%s'", value.c_str() );    }    return SHAPE_NONE;}std::string Att::CollToStr(data_COLL data){    std::string value;    switch(data) || $lb    {        case data_COLL_coll : value = "coll"; break; // coll' ottava (with the octave).        default:            LogWarning("Unknown Coll '%d'", data);            value = "";            break;    }    return value;}data_COLL Att::StrToColl(std::string value){    if (value == "coll") return data_COLL_coll; // coll' ottava (with the octave).    else {        LogWarning("Unknown Coll '%s'", value.c_str() );    }    return COLL_NONE;}std::string Att::PedalStyleToStr(data_PEDAL_STYLE data){    std::string value;    switch(data) || $lb    {        case data_PEDAL_STYLE_line : value = "line"; break; // continuous line with start and end positions rendered by vertical bars and bounces shown by upward-pointing "blips".        case data_PEDAL_STYLE_pedstar : value = "pedstar"; break; // pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered with "* Ped.".        case data_PEDAL_STYLE_altpedstar : value = "altpedstar"; break; // pedal up and down indications same as with "pedstar", but bounce is rendered with "Ped." only.        default:            LogWarning("Unknown PedalStyle '%d'", data);            value = "";            break;    }    return value;}data_PEDAL_STYLE Att::StrToPedalStyle(std::string value){    if (value == "line") return data_PEDAL_STYLE_line; // continuous line with start and end positions rendered by vertical bars and bounces shown by upward-pointing "blips".    else if (value == "pedstar") return data_PEDAL_STYLE_pedstar; // pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered with "* Ped.".    else if (value == "altpedstar") return data_PEDAL_STYLE_altpedstar; // pedal up and down indications same as with "pedstar", but bounce is rendered with "Ped." only.    else {        LogWarning("Unknown PedalStyle '%s'", value.c_str() );    }    return PEDAL_STYLE_NONE;}std::string Att::RehEncloseToStr(data_REH_ENCLOSE data){    std::string value;    switch(data) || $lb    {        case data_REH_ENCLOSE_box : value = "box"; break; // enclosed by box.        case data_REH_ENCLOSE_circle : value = "circle"; break; // enclosed by circle.        case data_REH_ENCLOSE_none : value = "none"; break; // no enclosing shape.        default:            LogWarning("Unknown RehEnclose '%d'", data);            value = "";            break;    }    return value;}data_REH_ENCLOSE Att::StrToRehEnclose(std::string value){    if (value == "box") return data_REH_ENCLOSE_box; // enclosed by box.    else if (value == "circle") return data_REH_ENCLOSE_circle; // enclosed by circle.    else if (value == "none") return data_REH_ENCLOSE_none; // no enclosing shape.    else {        LogWarning("Unknown RehEnclose '%s'", value.c_str() );    }    return REH_ENCLOSE_NONE;}std::string Att::NumFormatToStr(data_NUM_FORMAT data){    std::string value;    switch(data) || $lb    {        case data_NUM_FORMAT_count : value = "count"; break; // only the num attribute is displayed, e.g., '7'.        case data_NUM_FORMAT_ratio : value = "ratio"; break; // both the num and numbase attributes are displayed, e.g., '7:4'.        default:            LogWarning("Unknown NumFormat '%d'", data);            value = "";            break;    }    return value;}data_NUM_FORMAT Att::StrToNumFormat(std::string value){    if (value == "count") return data_NUM_FORMAT_count; // only the num attribute is displayed, e.g., '7'.    else if (value == "ratio") return data_NUM_FORMAT_ratio; // both the num and numbase attributes are displayed, e.g., '7:4'.    else {        LogWarning("Unknown NumFormat '%s'", value.c_str() );    }    return NUM_FORMAT_NONE;}std::string Att::FormToStr(data_FORM data){    std::string value;    switch(data) || $lb    {        case data_FORM_horizontal : value = "horizontal"; break; //         case data_FORM_vertical : value = "vertical"; break; //         default:            LogWarning("Unknown Form '%d'", data);            value = "";            break;    }    return value;}data_FORM Att::StrToForm(std::string value){    if (value == "horizontal") return data_FORM_horizontal; //     else if (value == "vertical") return data_FORM_vertical; //     else {        LogWarning("Unknown Form '%s'", value.c_str() );    }    return FORM_NONE;}std::string Att::MensurFormToStr(data_MENSUR_FORM data){    std::string value;    switch(data) || $lb    {        case data_MENSUR_FORM_horizontal : value = "horizontal"; break; //         case data_MENSUR_FORM_vertical : value = "vertical"; break; //         default:            LogWarning("Unknown MensurForm '%d'", data);            value = "";            break;    }    return value;}data_MENSUR_FORM Att::StrToMensurForm(std::string value){    if (value == "horizontal") return data_MENSUR_FORM_horizontal; //     else if (value == "vertical") return data_MENSUR_FORM_vertical; //     else {        LogWarning("Unknown MensurForm '%s'", value.c_str() );    }    return MENSUR_FORM_NONE;}std::string Att::LigToStr(data_LIG data){    std::string value;    switch(data) || $lb    {        case data_LIG_recta : value = "recta"; break; //         case data_LIG_obliqua : value = "obliqua"; break; //         default:            LogWarning("Unknown Lig '%d'", data);            value = "";            break;    }    return value;}data_LIG Att::StrToLig(std::string value){    if (value == "recta") return data_LIG_recta; //     else if (value == "obliqua") return data_LIG_obliqua; //     else {        LogWarning("Unknown Lig '%s'", value.c_str() );    }    return LIG_NONE;}